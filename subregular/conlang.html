<!DOCTYPE html>
<html>

<head>
    <title>Your Own MTSL Conlang</title>
    <link rel="stylesheet" href="https://pyscript.net/latest/pyscript.css" />
    <script defer src="https://pyscript.net/latest/pyscript.js"></script>
    <link rel="stylesheet" href="https://latex.now.sh/style.css">
    <style>
        :root {
            --body-bg-color: rgb(255, 240, 250);
        }

        .center,
        table,
        h1,
        h2,
        h3,
        h4,
        h5 {
            margin-left: auto;
            margin-right: auto;
        }

        .example>tbody>tr>td {
            font-style: italic;
            padding: 3px;
        }
    </style>
    
</head>

<body>
    <header>
        <h1>Your Own MTSL Conlang!</h1>
        <p class="author">Jacob Johnson</p>
    </header>
    <article class="indent-pars">
        <p>This is a fun little artistic project I made to show off some of what I have learned while working with <a href="https://nnnNNnnn.info/subregular">Subregular Languages</a>. This website generates a brand new MTSL Conlang each time the page is loaded. Based on recent research in computational phonology, this means that people should actually be quite able to learn these vocabulary items as an actual language, with an actual phonotactic system.</p>
        <p>For simplicity, I used <a href="https://en.wikipedia.org/wiki/Phoneme#Numbers_of_phonemes_in_different_languages">the most cross-linguistically common phonemes</a> for these conlangs' phonemic inventories. I pull the most common words from <a href="https://gist.github.com/deekayen/4148741">this github repo</a> to map the generated words to English words.</p>
        <p>Because my research in Subregular Languages has mainly pertained to Phonology, this generator does not generate any morphology (word parts) or syntax (word order). It may produce forms whose mappings to English words do not make complete morphological sense (although I did spend the time to find a list which seems to only include lemmas, or "root" forms of words, so hopefully this should be uncommon). Feel free to imagine whatever morphology and syntax you would like!</p>
        <p>It takes a few seconds to generate, so please be patient, and just refresh the page if the table does not come up within 20 seconds. Make sure you have JavaScript enabled as well. Enjoy :)</p>

        <table>
            <tr></tr>
        </table>

    </article>

    <py-script src="conlang.py">
    
        '''import re
        from itertools import product, permutations
        from random import randint, sample, shuffle

        vowels = ['a', 'e', 'i', 'o', 'u']
        consonants = ['p', 't', 'k', 'm', 'n']
        sigma = vowels + consonants

        def tsl_acceptor(tier, restrictions):
            def acceptor(w):
                w_projected = re.sub(f'[^{"".join(tier)}]', '', '>'+w+'<')
                for restriction in restrictions:
                    if (r :=''.join(restriction)) in w_projected:
                        return False
                return True
            return acceptor

        def mtsl_acceptor(tsl_grammars):
            def acceptor(w):
                for tsl_grammar in tsl_grammars:
                    if not tsl_acceptor(*tsl_grammar)(w):
                        return False
                return True
            return acceptor

        
        def generate_mtsl_acceptor():
            tsl_grammars = [
                                [['>','<']+sigma, [('>','<')]], #prevent empty words
                                [sigma, list(product(vowels, vowels, vowels)) + list(product(consonants, consonants, consonants))]
                           ]
            for _ in range(randint(3,8)):#pick 3-8 tiers
                tier = sample(list(sigma), randint(4,8)) #pick 4-8 symbols for the tier
                if randint(1, 100) < 5:#possbly add word boundaries to the tier
                    tier.append('<')
                if randint(1, 100) < 5:
                    tier.append('<')
                poss = list(permutations(tier, 2))
                restrictions = sample(poss, randint(7,11))#sample 7-11 possible restrictions for the tier
                tsl_grammars.append((tier, restrictions))
            return mtsl_acceptor(tsl_grammars)

        def star(sigma, maxLen, filt=lambda *x:True):
        	for count in range(maxLen+1):
        		for result in filter(filt, (''.join(w) for w in product(*(sigma for _ in range(count))))):
        			yield result

        def mitsl_language():
            return list(star(sigma, 5, generate_mtsl_acceptor()))
        conlang = mitsl_language()
        shuffle(conlang)

        url = 'http://gist.githubusercontent.com/deekayen/4148741/raw/98d35708fa344717d8eee15d11987de6c8e26d7d/1-1000.txt'

        from pyodide.http import open_url

        eList = []
        with open_url(url) as file:
            eList += file.read().split('\n')

        from js import document

        table = document.createElement("table") 
        tHeader = document.createElement("thead")
        hRow = document.createElement("tr")
        eHeader = document.createElement('td')
        eHeader.innerText = "English Word"
        cHeader = document.createElement('td')
        cHeader.innerText = "New Word"
        hRow.appendChild(eHeader)
        hRow.appendChild(cHeader)
        tHeader.appendChild(hRow)
        table.appendChild(tHeader)

        for i in range(min(len(conlang), len(eList))):
            row = document.createElement("tr")

            eCell = document.createElement("td")
            eCell.innerText = eList[i]
            row.appendChild(eCell)

            cCell = document.createElement("td")
            cCell.innerText = conlang[i]
            row.appendChild(cCell)

            table.appendChild(row);

        document.body.appendChild(table)'''

    </py-script>

</body>

</html>